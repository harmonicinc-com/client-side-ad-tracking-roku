import "pkg:/source/roku_modules/rokurequests/Requests.brs"
import "InitResponseParser.bs"
import "MetadataParser.bs"
import "DashParser.bs"
import "PodHelper.bs"
import "HlsParser.bs"
import "UrlResolver.bs"
import "MergeHelper.bs"
import "PlayedRangeTracker.bs"
import "LateBeaconHandler.bs"

class RAFX_SSAI
    __name__ = "harmonic"
    AdEvent = {
        PODS: "PodsFound",
        POD_START: "PodStart",
        START: "Start",
        IMPRESSION: "Impression",
        CREATIVE_VIEW: "creativeView",
        FIRST_QUARTILE: "FirstQuartile",
        MIDPOINT: "Midpoint",
        THIRD_QUARTILE: "ThirdQuartile",
        COMPLETE: "Complete",
        POD_END: "PodComplete",
        STREAM_END: "StreamEnd",
        ACCEPT_INVITATION: "AcceptInvitation",
        ERROR: "Error"
    }

    ErrorType = {
        INIT_REQUEST_FAILED: "InitRequestFailed",
        MANIFEST_REQUEST_FAILED: "ManifestRequestFailed",
        METADATA_REQUEST_FAILED: "MetadataRequestFailed",
        INVALID_RESPONSE_FORMAT: "InvalidResponseFormat",
        PARSING_ERROR: "ParsingError",
        INVALID_STREAM_URL: "InvalidStreamUrl",
        LATE_BEACON_FAILED: "LateBeaconFailed"
    }

    private msgType = {
        UNKNOWN: 0,
        POSITION: 1,
        METADATA: 2,
        FINISHED: 3,
        KEYEVENT: 4
    }

    private player
    private metadataUrl
    private useStitched
    private callbacks = {}
    private rafMetadata = {}
    private rafAdBreaks = invalid  ' Filtered adBreaks sent to RAF. RAF changes the `triggered` states
    private podRetentionSec = 0
    private initResponseParser
    private metadataParser
    private dashParser
    private hlsParser
    private podHelper
    private mergeHelper
    private playedRangeTracker
    private lateBeaconHandler
    private logLevel = 0
    private roku_ads
    private lastPingTime = 0

    private pingIntervalSec = 4
    private DEFAULT_PING_INTERVAL_SEC = 4
    private DEFAULT_POD_RETENTION_SEC = 60 * 60 * 2 ' 2 hours

    private adsInProgress = false

    sub new()
        m.initResponseParser = new InitResponseParser()
        m.metadataParser = new MetadataParser()
        m.metadataParser.setErrorCallback(sub(errorType, message, details)
            m.triggerError(errorType, message, details)
        end sub)
        ' Set the parsing error type on the parser
        m.metadataParser.setParsingErrorType(m.ErrorType.PARSING_ERROR)
        m.dashParser = new DashParser()
        m.hlsParser = new HlsParser()
        m.podHelper = new PodHelper()
        m.mergeHelper = new MergeHelper()
        m.playedRangeTracker = new PlayedRangeTracker()
        m.lateBeaconHandler = new LateBeaconHandler()
        m.lateBeaconHandler.setErrorCallback(sub(errorType, message, details)
            m.triggerError(errorType, message, details)
        end sub)
        ' Set the beacon error type on the handler
        m.lateBeaconHandler.setBeaconErrorType(m.ErrorType.LATE_BEACON_FAILED)
        m.roku_ads = Roku_Ads()
    end sub

    private function parseOptions(options as object) as object
        parsedOptions = {
            initRequest: true,
            podRetentionSec: m.DEFAULT_POD_RETENTION_SEC,
            pingIntervalSec: m.DEFAULT_PING_INTERVAL_SEC
        }

        if options = invalid
            return parsedOptions
        end if

        ' Parse initRequest
        if options["initRequest"] <> invalid
            parsedOptions.initRequest = options["initRequest"]
        end if

        ' Parse podRetentionSec
        if options["podRetentionSec"] <> invalid and options["podRetentionSec"] > 0
            parsedOptions.podRetentionSec = options["podRetentionSec"]
        end if

        ' Parse pingIntervalSec
        if options["pingIntervalSec"] <> invalid and options["pingIntervalSec"] > 0
            parsedOptions.pingIntervalSec = options["pingIntervalSec"]
        end if

        return parsedOptions
    end function

    ' param: URL - Live URL w/ sessId query param
    ' param: options - object - Options for the request (optional)
    '   - initRequest - boolean - True if the session init API should be called first to initialize the session. Default: true
    '   - podRetentionSec - integer - How long to cache ad metadata in seconds. Default: 7200 (2 hours)
    '   - pingIntervalSec - integer - Interval for metadata polling in seconds. Default: 4
    ' return assocarray:
    ' - ssai: boolean - True if SSAI is detected, false otherwise
    ' - streamUrl: string | invalid - Personalized stream URL with session ID.
    '                                     Only valid if ssai is true
    function getStreamInfo(url as string, options as object) as object
        result = {
            ssai: false,
            streamUrl: invalid
        }

        ' Parse options with defaults
        parsedOptions = m.parseOptions(options)
        m.podRetentionSec = parsedOptions.podRetentionSec
        m.pingIntervalSec = parsedOptions.pingIntervalSec
        initRequest = parsedOptions.initRequest

        if /^(?:https?:\/\/)?(?:[^@\/\n]+@)?(?:www\.)?([^:\/?\n]+)(?:\/pmm-[^\/]*)?\/variant/.isMatch(url)
            ' Extract hostname and base path in one go
            urlParts = /^(?:https?:\/\/)?(?:[^@\/?\n]+@)?(?:www\.)?([^:\/?\n]+)(\/.*?\/)[^\/]+$/g.match(url)
            hostname = urlParts[1]
            basePath = urlParts[2]

            ' Extract filename with query params and file extension
            fullFilename = /[^\/]+(\?[^\/]*)?$/g.match(url)[0]
            fileExt = /\.(\w{3,4})($|\?)/g.match(url)[1]

            ' Get the URLs from the init request if initRequest is true
            if initRequest
                initInfo = m.getInitRequestInfo(url)
                if initInfo.manifestUrl <> invalid and initInfo.trackingUrl <> invalid
                    m.log(`Response from init request successfully parsed. manifest: ${initInfo.manifestUrl}, metadata: ${initInfo.trackingUrl}`)

                    result.streamUrl = ResolveUrl(hostname, basePath, initInfo.manifestUrl)
                    m.metadataUrl = ResolveUrl(hostname, basePath, initInfo.trackingUrl)

                    if result.streamUrl <> invalid
                        manifest = rokurequests_Requests().get(result.streamUrl)
                        m.dashParser.setManifest(manifest.text)
                        if m.dashParser.isDash(manifest.headers["content-type"], fileExt)
                            m.metadataParser.availabilityStartTime.setLongInt(m.dashParser.getAvailabilityStartTime())
                        end if

                        m.rafMetadata = m.requestMetadata()
                        result.ssai = m.rafMetadata <> invalid
                    else
                        m.log("Failed to construct stream URL from initInfo.")
                        m.triggerError(m.ErrorType.INVALID_STREAM_URL, "Failed to construct stream URL from init info", { url: url })
                    end if

                    return result
                else
                    m.log("init request failed, falling back to obtaining manifest directly")
                    m.triggerError(m.ErrorType.INIT_REQUEST_FAILED, "Init request failed, falling back to manifest request", { url: url })
                end if
            end if

            ' need to send a manifest request first, or session won't be created
            manifest = rokurequests_Requests().get(url)
            m.dashParser.setManifest(manifest.text)
            
            streamUrl = invalid
            if m.dashParser.isDash(manifest.headers["content-type"], fileExt)
                ' Handle DASH
                m.metadataParser.availabilityStartTime.setLongInt(m.dashParser.getAvailabilityStartTime())
                streamUrl = m.dashParser.getLocation()
            else if fileExt = "m3u8"
                ' Handle HLS
                m.hlsParser.setPlaylist(manifest.text)
                streamUrl = m.hlsParser.getFirstMediaPlaylistUrl()
            end if
    
            if streamUrl <> invalid
                finalUrl = ResolveUrl(hostname, basePath, streamUrl)
                
                ' Replace filename with metadata, ignore any extension
                m.metadataUrl = /\/[^\/\.?]+(?:\.[^\/\.?]+)?(\??[^\/]*$)/g.replaceAll(finalUrl, "/metadata\1")
                
                m.rafMetadata = m.requestMetadata()
                result.ssai = m.rafMetadata <> invalid
                result.streamUrl = result.ssai ? /\/[^\/\.?]+(?:\.[^\/\.?]+)?(\??[^\/]*$)/g.replaceAll(finalUrl, "/"+fullFilename+"\1") : invalid
            end if
        end if
        return result
    end function

    private function getInitRequestInfo(url as string) as object
        result = {
            manifestUrl: invalid,
            trackingUrl: invalid
        }

        ' First try GET request with initSession=true query param
        getUrl = url
        if url.instr("?") > -1
            getUrl = url + "&initSession=true"
        else
            getUrl = url + "?initSession=true"
        end if
        
        initResponse = rokurequests_Requests().get(getUrl)
        
        if initResponse <> invalid and initResponse.ok and initResponse.statusCode = 200
            ' Parse the urls from the response
            m.initResponseParser.setResponseJson(initResponse.json)

            ' Extract the manifest and tracking URLs
            manifestUrlPath = m.initResponseParser.getManifestUrl()
            trackingUrlPath = m.initResponseParser.getTrackingUrl()
            
            ' Check if both URLs were successfully parsed
            if manifestUrlPath <> invalid and trackingUrlPath <> invalid
                result.manifestUrl = manifestUrlPath
                result.trackingUrl = trackingUrlPath
                return result
            else
                m.log("GET init request succeeded but failed to parse URLs, falling back to POST request")
                m.triggerError(m.ErrorType.INVALID_RESPONSE_FORMAT, "Failed to parse URLs from GET init response", { response: initResponse.json })
            end if
        else
            m.log("GET init request failed, falling back to POST request")
            m.triggerError(m.ErrorType.INIT_REQUEST_FAILED, "GET init request failed", { statusCode: initResponse?.statusCode, url: getUrl })
        end if

        ' Fallback to POST init request
        initResponse = rokurequests_Requests().post(url, {})

        if initResponse = invalid or not initResponse.ok or initResponse.statusCode <> 200
            m.log("POST init request failed with status code: " + initResponse.statusCode.tostr())
            m.triggerError(m.ErrorType.INIT_REQUEST_FAILED, "POST init request failed", { statusCode: initResponse?.statusCode, url: url })
            ' Should fallback parsing manifest
        else
            ' Parse the urls from the response
            m.initResponseParser.setResponseJson(initResponse.json)

            ' Extract the manifest and tracking URLs
            manifestUrlPath = m.initResponseParser.getManifestUrl()
            if manifestUrlPath <> invalid
                result.manifestUrl = manifestUrlPath
            end if

            trackingUrlPath = m.initResponseParser.getTrackingUrl()
            if trackingUrlPath <> invalid
                result.trackingUrl = trackingUrlPath
            end if
        end if

        return result
    end function

    function requestMetadata()
        if m.metadataUrl <> invalid
            r = rokurequests_Requests().get(m.metadataUrl)
            if r.ok and r.statusCode = 200 and r.headers?.["content-type"] = "application/json" and r.json <> invalid
                return m.metadataParser.parseMetadata(r.json)
            else
                m.log("Metadata request failed with status code: " + r.statusCode.tostr())
                m.triggerError(m.ErrorType.METADATA_REQUEST_FAILED, "Metadata request failed", { 
                    statusCode: r?.statusCode, 
                    url: m.metadataUrl,
                    contentType: r?.headers?.["content-type"]
                })
            end if
        end if
        return invalid
    end function

    sub mergePods(newPods as object)
        ' Sync triggered states from RAF's copy back to our metadata before merging
        m.syncTriggeredStatesFromRAF()
        
        ' Deep clone
        current = parseJson(formatJson(m.rafMetadata.adBreaks))
        playhead = m.player.sgNode.position ?? 0
        adOpportunities = 0

        ' Assume pods are in chronological order
        for each pod in current
            if playhead - pod.renderTime < m.podRetentionSec
                newPod = m.mergeHelper.findPodById(newPods.adBreaks, pod.id)
                if newPod <> invalid
                    ' Old pod. Keep until expired.
                    if newPod.duration <> pod.duration
                        pod.duration = newPod.duration
                    end if
                    m.mergeHelper.mergeAds(pod.ads, newPod.ads)
                end if
                adOpportunities += pod.ads.count()
            else
                ' Evict expired pods
                current.shift()
            end if
        end for

        for each newPod in newPods.adBreaks
            podExist = m.mergeHelper.findPodById(current, newPod.id)
            if podExist = invalid
                if current.count() = 0
                    current.push(newPod)
                else
                    current = m.podHelper.binaryInsert(current, newPod)
                end if
                adOpportunities += newPod.ads.count()
            end if
        end for

        m.rafMetadata.adOpportunities = adOpportunities
        m.rafMetadata.adBreaks = current
    end sub

    ' Sync triggered states from RAF's copy (rafAdBreaks) back to our metadata (rafMetadata)
    private sub syncTriggeredStatesFromRAF()
        if m.rafAdBreaks = invalid or m.rafMetadata.adBreaks = invalid
            return
        end if

        totalEvents = 0
        triggeredEvents = 0
        
        for each rafPod in m.rafAdBreaks
            existingPod = m.mergeHelper.findPodById(m.rafMetadata.adBreaks, rafPod.id)
            if existingPod <> invalid
                for each rafAd in rafPod.ads
                    existingAd = m.mergeHelper.findAdById(existingPod.ads, rafAd.id)
                    if existingAd <> invalid
                        ' Sync triggered states from RAF's tracking to our existing rafMetadata by matching event and time
                        for each rafEvent in rafAd.tracking
                            totalEvents += 1
                            if rafEvent.triggered
                                triggeredEvents += 1
                                eventTime = rafEvent.doesExist("time") ? rafEvent.time : invalid
                                existingEvent = m.mergeHelper.findTrackingEvent(existingAd.tracking, rafEvent.event, eventTime)
                                if existingEvent <> invalid
                                    existingEvent.triggered = true
                                end if
                            end if
                        end for
                    end if
                end for
            end if
        end for

        m.log(`syncTriggeredStatesFromRAF(): ${triggeredEvents}/${totalEvents} events marked as triggered`)
    end sub

    ' Process late metadata and fire beacons for already played ads
    private sub processLateMetadata(adBreaks as object)
        if adBreaks = invalid or adBreaks.count() = 0 then return
        
        if m.lateBeaconHandler <> invalid
            m.lateBeaconHandler.init(m.playedRangeTracker, m.log)
            m.lateBeaconHandler.processLateMetadata(adBreaks)
        end if
    end sub

    ' params:
    ' - player: Player params
    '   - sgNode: Video node
    '   - port: Player port
    ' - useStitched: Adapter will fire the events if true. Client needs to handle the callback if false.
    sub enableAds(params as object)
        valid = false
        if type(params["player"]) = "roAssociativeArray"
            player = params["player"]
            if player.doesexist("port") and player.doesexist("sgNode")
                valid = true
            end if
            m.player = player
        end if
        m.useStitched = (invalid = params["useStitched"] or params["useStitched"])
        if m.useStitched
            ' WIP
        end if

        if not valid
            print "Invalid params"
            return
        end if
        m.setRAFAdPods(m.rafMetadata.adBreaks)
    end sub

    function onMessage(msg as object) as object
        msgType = m.getMsgType(msg, m.player)
        if msgType = m.msgType.FINISHED
            m.log("All video is completed - full result")
            m.doCall(m.AdEvent.STREAM_END, {})
        else if msgType = m.msgType.METADATA
            m.onMetadata(msg)
        else if msgType = m.msgType.POSITION
            m.onPosition(msg)
        else if invalid <> msg and msgType = m.msgType.UNKNOWN
            m.onUnknown(msg)
        end if
        curAd = m.msgToRAF(msg)
        return curAd
    end function

    sub addEventListener(event as string, callback as function)
        m.callbacks[event] = callback
    end sub

    private sub onMetadata(msg as object)
        ' WIP
    end sub

    ' Criteria to trigger metadata fetch
    ' - Ads not playing (as mutating the pods will trigger Roku to refire all events), AND
    ' - m.metadataParser.startTime = 0 (first fetch only), OR
    ' - m.pingIntervalSec passed since last fetch
    private sub onPosition(msg as object)
        playerPosition = m.player?.sgNode?.position ?? 0
        
        ' Track played position for late metadata handling
        if playerPosition > 0 and m.playedRangeTracker <> invalid
            m.playedRangeTracker.trackPosition(playerPosition)
        end if
        
        forcePing = false
        if m.metadataParser <> invalid and m.metadataParser.startTime <> invalid
            if m.metadataParser.startTime = 0
                playerVideo = m.player?.sgNode?.positioninfo?.video ?? 0
                if playerVideo > 0 and playerPosition > 0
                    m.metadataParser.startTime.setLongInt(playerVideo - playerPosition)
                    forcePing = true
                end if
            end if
        end if
        currentTime = createObject("roDateTime").AsSeconds()
        if (forcePing or (currentTime - m.lastPingTime > m.pingIntervalSec)) and not m.adsInProgress
            newAds = m.requestMetadata()
            ' Ads are invalid if playhead is outside time range
            if newAds <> invalid
                m.mergePods(newAds)

                ' Fire beacons for already played ads
                m.processLateMetadata(m.rafMetadata.adBreaks)
                
                m.setRAFAdPods(m.rafMetadata.adBreaks)
                m.lastPingTime = currentTime
            end if

            ' Clean up old played ranges
            if m.playedRangeTracker <> invalid
                m.playedRangeTracker.cleanupOldRanges(playerPosition, m.podRetentionSec)
            end if
        end if
    end sub

    private sub onUnknown(msg as object)
    end sub

    private function msgToRAF(msg as object)
        if m.useStitched
            ads = m.roku_ads.stitchedAdHandledEvent(msg, m.player)
            m.adsInProgress = ads <> invalid
            m.syncTriggeredStatesFromRAF()
            ' Use the unfiltered adBreaks (with triggered states synced) for callback
            m.doCall(m.AdEvent.PODS, { event: m.AdEvent.PODS, adPods: m.rafMetadata.adBreaks })
            return ads
        end if
        return invalid
    end function

    ' Helper function to trigger error callbacks
    private sub triggerError(errorType as string, message as string, details = invalid as dynamic)
        errorInfo = {
            event: m.AdEvent.ERROR,
            errorType: errorType,
            message: message,
            timestamp: CreateObject("roDateTime").AsSeconds(),
            details: details
        }
        m.doCall(m.AdEvent.ERROR, errorInfo)
    end sub

    private sub doCall(event as string, adInfo as object)
        if m.callbacks[event] <> invalid
            func = m.funcCall
            func(m.callbacks[event], adInfo)
        end if
    end sub

    private sub funcCall(dd as function, ue as object) as void
        dd(ue)
    end sub

    private function getMsgType(msg as object, player as object) as integer
        nodeId = player.sgNode.id
        if "roSGNodeEvent" = type(msg)
            xg = msg.getField()
            if nodeId = msg.getNode()
                if xg = "position"
                    return m.msgType.POSITION
                else if xg.left(13) = "timedMetaData"
                    return m.msgType.METADATA
                else if xg = "state"
                    if msg.getData() = "finished"
                        return m.msgType.FINISHED
                    end if
                end if
            else
                if xg = "keypressed"
                    return m.msgType.KEYEVENT
                end if
            end if
        end if
        return m.msgType.UNKNOWN
    end function

    private sub setRAFAdPods(adBreaks as object)
        if adBreaks <> invalid and 0 < adBreaks.count()
            if m.useStitched
                ' Create filtered copy for RAF with only untriggered beacons
                m.rafAdBreaks = m.mergeHelper.filterTriggeredBeacons(adBreaks)
                m.roku_ads.stitchedAdsInit(m.rafAdBreaks)
            end if
            ' Use the unfiltered adBreaks (with triggered states synced) for callback
            m.doCall(m.AdEvent.PODS, { event: m.AdEvent.PODS, adPods: adBreaks })
        end if
    end sub

    private sub log(x, logLevel = -1 as integer)
        if logLevel < m.logLevel
            ddttm = createObject("roDateTime")
            dtm = ["Harmonic_RAFX_SSAI (", ddttm.toISOString().split("T")[1], " ", ddttm.getMilliseconds().tostr(), "): "].join("")
            if "roArray" = type(x)
                print dtm; x.join("")
            else
                print dtm; x
            end if
        end if
    end sub

end class
