import "pkg:/source/roku_modules/rokurequests/Requests.brs"

function ParseUrl(url as string) as object
    result = {
        protocol: invalid,
        host: invalid,
        port: invalid,
        path: invalid,
        filename: invalid,
        extension: invalid,
        query: invalid,
        fullPath: invalid
    }

    if url = invalid or url = "" then return result

    remainingUrl = url

    ' Extract Query String
    queryIndex = remainingUrl.Instr("?")
    if queryIndex >= 0
        result.query = remainingUrl.Mid(queryIndex + 1)
        remainingUrl = remainingUrl.Left(queryIndex)
    end if

    ' Extract Protocol
    protocolIndex = remainingUrl.Instr("://")
    if protocolIndex >= 0
        result.protocol = remainingUrl.Left(protocolIndex + 3)
        remainingUrl = remainingUrl.Mid(protocolIndex + 3)
    end if

    ' Extract Host and Port
    slashIndex = remainingUrl.Instr("/")
    hostPart = ""
    if slashIndex >= 0
        hostPart = remainingUrl.Left(slashIndex)
        result.fullPath = remainingUrl.Mid(slashIndex + 1)
    else
        hostPart = remainingUrl
        result.fullPath = ""
    end if

    ' Handle Port
    colonIndex = hostPart.Instr(":")
    if colonIndex >= 0
        result.host = hostPart.Left(colonIndex)
        result.port = hostPart.Mid(colonIndex + 1)
    else
        result.host = hostPart
    end if

    ' Extract Path (directory) and Filename
    if result.fullPath <> invalid
        lastSlashIndex = -1
        for i = result.fullPath.Len() - 1 to 0 step -1
            if result.fullPath.Mid(i, 1) = "/"
                lastSlashIndex = i
                exit for
            end if
        end for

        if lastSlashIndex >= 0
            result.path = result.fullPath.Left(lastSlashIndex)
            result.filename = result.fullPath.Mid(lastSlashIndex + 1)
        else
            result.path = "/"
            result.filename = result.fullPath
        end if
    end if

    ' Extract Extension
    if result.filename <> invalid and result.filename <> ""
        lastDotIndex = -1
        for i = result.filename.Len() - 1 to 0 step -1
            if result.filename.Mid(i, 1) = "."
                lastDotIndex = i
                exit for
            end if
        end for
        
        if lastDotIndex >= 0
            result.extension = result.filename.Mid(lastDotIndex + 1)
        end if
    end if

    return result
end function

function ResolveUrl(baseUrl as string, receivedUrl as string) as string
    '  If URL is absolute, use it directly
    if Left(LCase(receivedUrl), 4) = "http"
        return receivedUrl
    end if

    parsedBase = ParseUrl(baseUrl)
    if parsedBase.host = invalid or parsedBase.host = ""
        return invalid
    end if

    protocol = parsedBase.protocol
    if protocol = invalid
        protocol = "https://"
    end if
    
    hostname = parsedBase.host
    if parsedBase.port <> invalid
        hostname = hostname + ":" + parsedBase.port
    end if

    basePath = parsedBase.path
    if basePath = invalid then basePath = "/"

    ' For root-relative URLs (starting with "/")
    if Left(receivedUrl, 1) = "/"
        return protocol + hostname + receivedUrl
    end if

    ' For relative URLs with ./ or ../ in the path
    baseSegments = basePath.split("/")
    relSegments = receivedUrl.split("/")

    ' Remove empty segments from the end of baseSegments
    while baseSegments.count() > 0 and baseSegments[baseSegments.count() - 1] = ""
        baseSegments.pop()
    end while

    ' Walk through relSegments and resolve ., ..
    for each seg in relSegments
        if seg = ".."
            if baseSegments.count() > 0 then baseSegments.pop()
        else if seg = "." or seg = ""
            ' Do nothing (stay in current directory or ignore empty)
        else
            baseSegments.push(seg)
        end if
    end for

    ' Join segments back, ensure leading slash
    urlPath = "/" + baseSegments.Join("/")

    ' Remove potential double slashes
    while urlPath.Instr("//") >= 0
        urlPath = urlPath.Replace("//", "/")
    end while

    return protocol + hostname + urlPath
end function

' Helper function to handle HTTP request with one redirect follow
' Returns an object with response and finalUrl (after redirect if applicable)
function MakeRequestWithRedirect(method as string, url as string, args = invalid as dynamic, ctx = invalid as object) as object
    result = {
        response: invalid,
        finalUrl: url
    }

    if ctx <> invalid and ctx.log <> invalid
        ctx.log("MakeRequestWithRedirect: Making " + method + " request to URL: " + url)
    end if

    ' Make initial request
    requests = rokurequests_Requests()
    if method = "GET"
        result.response = requests.get(url, args)
    else if method = "POST"
        result.response = requests.post(url, args)
    end if

    ' Check if we got a redirect (the final response statusCode will not be 3xx; so we only follow redirect if the location header is present)
    if result.response <> invalid and result.response.statusCode < 400
        ' Extract Location header for redirect
        locationHeader = result.response.headers?["location"]
        if locationHeader <> invalid and locationHeader <> ""
            if ctx <> invalid and ctx.log <> invalid
                ctx.log("MakeRequestWithRedirect: Following redirect to: " + locationHeader)
            end if
            
            ' Resolve the redirect URL (may be relative or absolute)
            redirectUrl = ResolveUrl(url, locationHeader)

            if redirectUrl = invalid
                if ctx <> invalid and ctx.log <> invalid
                    ctx.log("MakeRequestWithRedirect: Failed to resolve redirect URL from Location header: " + locationHeader)
                end if
                return result
            end if

            ' Follow the redirect (only once)
            if method = "GET"
                result.response = requests.get(redirectUrl, args)
            else if method = "POST"
                result.response = requests.post(redirectUrl, args)
            end if
            
            result.finalUrl = redirectUrl
        end if
    end if

    return result
end function
