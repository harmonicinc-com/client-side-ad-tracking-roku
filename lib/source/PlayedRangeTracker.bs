class PlayedRangeTracker
    ' Tracks time ranges that have been played
    ' Merges overlapping or adjacent ranges

    private playedRanges = []
    private positionTrackingInterval = 0.5  ' 500ms tolerance for continuity

    ' Track a played position and merge ranges
    sub trackPosition(position as float)
        if position < 0 then return
        
        if m.playedRanges.count() = 0
            ' First range
            m.playedRanges.push({start: position, end: position})
            return
        end if
        
        ' Check if this position continues from or overlaps with any existing range
        merged = false
        for i = 0 to m.playedRanges.count() - 1
            range = m.playedRanges[i]
            
            ' Check if position extends or overlaps this range
            if m.isPositionNearRange(position, range)
                ' Extend the range
                if position < range.start
                    range.start = position
                else if position > range.end
                    range.end = position
                end if
                merged = true
                
                ' After extending, check if we can merge with adjacent ranges
                m.mergeAdjacentRanges()
                exit for
            end if
        end for
        
        if not merged
            ' Position doesn't connect to any existing range - create new range
            m.playedRanges.push({start: position, end: position})
            ' Sort ranges by start time
            m.sortRanges()
            ' Try to merge any adjacent ranges
            m.mergeAdjacentRanges()
        end if
        
    end sub

    ' Check if a position is near enough to a range to extend it
    private function isPositionNearRange(position as float, range as object) as boolean
        ' Position is near if it's within the range or within tolerance of the edges
        tolerance = m.positionTrackingInterval * 2
        return (position >= range.start - tolerance) and (position <= range.end + tolerance)
    end function

    ' Merge overlapping or adjacent ranges
    private sub mergeAdjacentRanges()
        if m.playedRanges.count() <= 1 then return
        
        merged = []
        current = m.playedRanges[0]
        
        for i = 1 to m.playedRanges.count() - 1
            nextRange = m.playedRanges[i]
            
            ' Check if ranges overlap or are adjacent (within tolerance)
            tolerance = m.positionTrackingInterval * 2
            if current.end + tolerance >= nextRange.start
                ' Merge ranges
                current.end = m.max(current.end, nextRange.end)
                current.start = m.min(current.start, nextRange.start)
            else
                ' No overlap, save current and move to next
                merged.push(current)
                current = nextRange
            end if
        end for
        
        ' Add the last range
        merged.push(current)
        m.playedRanges = merged
    end sub

    ' Sort ranges by start time
    private sub sortRanges()
        n = m.playedRanges.count()
        for i = 0 to n - 2
            for j = 0 to n - i - 2
                if m.playedRanges[j].start > m.playedRanges[j + 1].start
                    temp = m.playedRanges[j]
                    m.playedRanges[j] = m.playedRanges[j + 1]
                    m.playedRanges[j + 1] = temp
                end if
            end for
        end for
    end sub

    ' Check if a time point was played
    function wasTimePlayed(time as float) as boolean
        for each range in m.playedRanges
            if time >= range.start and time <= range.end
                return true
            end if
        end for
        return false
    end function

    ' Clean up old ranges beyond retention time
    sub cleanupOldRanges(currentPosition as float, retentionSec as float)
        newRanges = []
        for each range in m.playedRanges
            if currentPosition - range.end < retentionSec
                newRanges.push(range)
            end if
        end for
        m.playedRanges = newRanges
    end sub

    ' Get all played ranges
    function getRanges() as object
        return m.playedRanges
    end function

    ' Clear all ranges
    sub clearRanges()
        m.playedRanges = []
    end sub

    ' Get count of ranges
    function getRangeCount() as integer
        return m.playedRanges.count()
    end function

    ' Helper functions
    private function max(a as float, b as float) as float
        if a > b then return a
        return b
    end function

    private function min(a as float, b as float) as float
        if a < b then return a
        return b
    end function

end class
